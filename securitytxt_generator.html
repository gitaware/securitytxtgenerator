<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>security.txt Generator + PGP Signing</title>
  <script src="https://unpkg.com/openpgp@5.10.1/dist/openpgp.min.js"></script>
  <style>
    body { font-family: Arial; padding: 2em; background: #f4f4f4; max-width: 800px; margin: auto; }
    label { font-weight: bold; margin-top: 1em; display: block; }
    input, select, textarea, button { width: 100%; margin-top: 0.3em; padding: 0.5em; box-sizing: border-box; }
    textarea { height: 200px; font-family: monospace; }
    .row { display: flex; gap: 1em; }
    .row > div { flex: 1; }
    .buttons { display: flex; gap: 1em; margin-top: 0.5em; }

    .password-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    .password-wrapper input {
      width: 100%;
      padding-right: 2.5em;
      padding-left: 0.5em;
      height: 2.5em;
      font-size: 1em;
      box-sizing: border-box;
    }

    .toggle-visibility {
      position: absolute;
      right: 0.5em;
      cursor: pointer;
      user-select: none;
      font-size: 1.2em;
      color: #444;
    }

    #toast {
      visibility: hidden;
      min-width: 200px;
      background-color: #333;
      color: #fff;
      text-align: center;
      border-radius: 8px;
      padding: 0.75em 1em;
      position: fixed;
      z-index: 9999;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.9em;
      opacity: 0;
      transition: opacity 0.3s ease, visibility 0.3s;
    }

    #toast.show {
      visibility: visible;
      opacity: 1;
    }

  .required-label {
    color: red;
    font-size: 0.8em;
    margin-left: 0.5em;
    font-weight: normal;
  }

  .error-message {
    color: red;
    font-size: 0.85em;
    margin-top: 0.2em;
    display: none;
  }
  input.invalid {
    border-color: red;
  }

  .canonical-row {
    display: flex;
    gap: 0.5em;
    align-items: center;
    margin-bottom: 0.5em;
  }

  .canonical-row input {
    flex: 1;
    padding: 0.5em;
    font-size: 1em;
    box-sizing: border-box;
  }

  .canonical-row button {
    flex: 0 0 auto;
    background: none;
    border: none;
    color: #c00;
    font-size: 1.2em;
    cursor: pointer;
    padding: 0.3em;
  }

  .btn-remove-canonical {
    width: auto; /* natural width */
    flex: 0 0 auto;
    padding: 0.3em 0.6em;
    font-size: 1.2em;
    cursor: pointer;
    background: none;
    border: none;
    color: #c00;
    line-height: 1;
  }

  #canonicalContainer {
    width: 100%;
  }

  </style>

  <script>
  const APP_VERSION = 'v 1.1';
  document.addEventListener('DOMContentLoaded', () => {
    const splash = document.getElementById('splashModal');
    const footer = document.getElementById('appFooter');
    const splashcontent = `<p>security.txt generator</p><p>For sourcecode see <a href="https://github.com/gitaware/securitytxtgenerator">github</a></p><p>${APP_VERSION} (c)2025 <a href="https://cloudaware.eu">CloudAware.eu</a></p>`;
    const footercontent = `${APP_VERSION} (c)2025 <a href="https://cloudaware.eu">CloudAware.eu</a>`;

    splash.innerHTML = splashcontent;
    footer.innerHTML = footercontent.replace('white', '#666'); // Use darker color for footer link

    splash.addEventListener('click', () => {
      splash.style.display = 'none';
    });

    addCanonicalField();
  });

  function generateSecurityTxt() {
    const contact = document.getElementById('contact').value.trim();
    const expiresInput = document.getElementById('expires').value;
    const langs = Array.from(document.getElementById('languages').selectedOptions)
                       .map(opt => opt.value).join(',');

    const canonicals = Array.from(document.querySelectorAll('#canonicalContainer input'))
                            .map(input => input.value.trim())
                            .filter(val => val !== '');

    // Validation
    const errors = [];
    if (!contact) errors.push("Contact is required.");
    if (!expiresInput) errors.push("Expires is required.");

    canonicals.forEach((url, index) => {
      try {
        const u = new URL(url);
        if (!u.href.endsWith('security.txt')) {
          errors.push(`Canonical URL ${index + 1} must end with "security.txt"`);
        }
      } catch {
        errors.push(`Canonical URL ${index + 1} is not a valid URL.`);
      }
    });

    if (errors.length > 0) {
      alert(errors.join('\n'));
      return;
    }

    const expires = new Date(expiresInput).toISOString().replace(/\.\d+Z$/, 'Z');

    let txt = '';
    if (contact) txt += `Contact: ${contact}\n`;
    if (expires) txt += `Expires: ${expires}\n`;
    if (langs) txt += `Preferred-Languages: ${langs}\n`;
    canonicals.forEach(url => {
      txt += `Canonical: ${url}\n`;
    });

    document.getElementById('securityOutput').value = txt;
  }

  function setFutureDate(years) {
    const future = new Date();
    future.setFullYear(future.getFullYear() + years);
    document.getElementById('expires').value = future.toISOString().slice(0, 16);
  }

  async function signSecurityTxt() {
    const armoredPrivateKey = document.getElementById('privateKey').value.trim();
    const passphrase = document.getElementById('passphrase').value;
    const message = document.getElementById('securityOutput').value;

    if (!armoredPrivateKey || !message) {
      alert("Please provide both a private key and a security.txt message.");
      return;
    }

    try {
      const privateKey = await openpgp.readPrivateKey({ armoredKey: armoredPrivateKey });

      let signingKey = privateKey;
      if (privateKey.isDecrypted() === false) {
        signingKey = await openpgp.decryptKey({
          privateKey,
          passphrase
        });
      }

      const signed = await openpgp.sign({
        message: await openpgp.createCleartextMessage({ text: message }),
        signingKeys: signingKey
      });

      document.getElementById('signedOutput').value = signed;
    } catch (err) {
      alert("Signing failed: " + err.message);
    }
  }

  async function generatePGPKey() {
    const name = prompt("Enter your name or email for the PGP key:", "security@example.com");
    if (!name) return;

    const { privateKey } = await openpgp.generateKey({
      type: 'rsa',
      rsaBits: 4096,
      userIDs: [{ name }],
      passphrase: ''
    });

    document.getElementById('privateKey').value = privateKey;
    alert("PGP Key generated. You can now sign your security.txt!");
    generatePassphrase();
  }

  async function downloadPrivateKey() {
    const armoredPrivateKey = document.getElementById('privateKey').value.trim();
    const passphrase = document.getElementById('passphrase').value;

    if (!armoredPrivateKey) {
      alert("No private key found to download.");
      return;
    }

    if (!passphrase) {
      alert("Please enter a passphrase to encrypt the exported private key.");
      return;
    }

    try {
      const privateKey = await openpgp.readPrivateKey({ armoredKey: armoredPrivateKey });

      const encryptedKey = await openpgp.encryptKey({
        privateKey,
        passphrase
      });

      const blob = new Blob([encryptedKey.armor()], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'private-key-encrypted.asc';
      a.click();
      URL.revokeObjectURL(url);
    } catch (err) {
      alert("Encryption failed: " + err.message);
    }
  }

  function generatePassphrase(length = 24) {
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+[]{}<>?';
    let passphrase = '';
    const randomValues = new Uint32Array(length);
    crypto.getRandomValues(randomValues);

    for (let i = 0; i < length; i++) {
      passphrase += charset[randomValues[i] % charset.length];
    }

    document.getElementById('passphrase').value = passphrase;
  }

  async function copyPassphrase() {
    const passInput = document.getElementById('passphrase');
    const passphrase = passInput.value;

    try {
      await navigator.clipboard.writeText(passphrase);
      showToast("✅ Passphrase copied!");
    } catch (err) {
      showToast("❌ Failed to copy.");
    }
  }

  function showToast(message) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = "show";
    setTimeout(() => {
      toast.className = toast.className.replace("show", "");
    }, 2000);
  }

  function togglePassphrase() {
    const passInput = document.getElementById('passphrase');
    const toggleIcon = document.querySelector('.toggle-visibility');

    if (passInput.type === 'password') {
      passInput.type = 'text';
      toggleIcon.textContent = '🙈'; // hide icon
    } else {
      passInput.type = 'password';
      toggleIcon.textContent = '👁️'; // show icon
    }
  }

  function downloadSignedFile() {
    const signed = document.getElementById('signedOutput').value;
    const blob = new Blob([signed], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'security.txt';
    a.click();
    URL.revokeObjectURL(url);
  }

  function addCanonicalField(value = '') {
    const container = document.getElementById('canonicalContainer');
    const row = document.createElement('div');
    row.className = 'canonical-row';

    const input = document.createElement('input');
    input.type = 'url';
    input.placeholder = 'https://example.com/.well-known/security.txt';
    input.value = value;

    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.innerHTML = '🗑️';
    removeBtn.title = 'Remove';
    removeBtn.className = 'btn-remove-canonical';
    removeBtn.onclick = () => {
      if (container.children.length > 1) {
        container.removeChild(row);
        toggleTrashVisibility();
      }
    };

    row.appendChild(input);
    row.appendChild(removeBtn);
    container.appendChild(row);
    toggleTrashVisibility();
  }

  function toggleTrashVisibility() {
    const rows = document.querySelectorAll('#canonicalContainer .canonical-row');
    rows.forEach((row, index) => {
      const btn = row.querySelector('button');
      btn.style.visibility = rows.length > 1 ? 'visible' : 'hidden';
    });
  }

  document.getElementById('keyFile').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const text = await file.text();
    document.getElementById('privateKey').value = text;
  });
  </script>
</head>
<body>
<div id="splashModal" style="
  position: fixed;
  top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0, 0, 0, 0.75);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5em;
  z-index: 10000;
  text-align: center;
  padding: 2em;
  cursor: pointer;
"></div>

<h2>security.txt Generator + PGP Signing</h2>

<form id="secForm">
  <label>Contact <span class="required-label">required</span></label>
  <input type="text" id="contact" required placeholder="mailto:security@example.com" />
  <div id="contactError" class="error-message">Contact is required.</div>

  <label>Expires <span class="required-label">required</span></label>
  <input type="datetime-local" required id="expires" />
  <div id="expiresError" class="error-message">Expires date is required.</div>
  <div class="buttons">
    <button type="button" onclick="setFutureDate(1)">+1 Year</button>
  </div>

  <label>Preferred-Languages</label>
  <select id="languages" multiple>
    <option value="en">en</option>
    <option value="nl">nl</option>
    <option value="fr">fr</option>
    <option value="de">de</option>
    <option value="pt">pt</option>
  </select>

  <label>Canonical <small style="color: red;">(optional, must end in <code>security.txt</code>)</small></label>
  <div id="canonicalContainer"></div>
  <button type="button" onclick="addCanonicalField()">➕ Add Canonical</button>

  <button type="button" onclick="generateSecurityTxt()">📝 Generate security.txt</button>
  <label>security.txt Output</label>
  <textarea id="securityOutput"></textarea>

  <label>PGP Options</label>
  <div class="row">
    <button type="button" onclick="generatePGPKey()">🔐 Generate New 4096-bit Key</button>
    <input type="file" accept=".asc" id="keyFile" />
  </div>

  <label>PGP Private Key (ASCII)</label>
  <textarea id="privateKey" placeholder="-----BEGIN PGP PRIVATE KEY-----"></textarea>

  <label>Passphrase (do not loose!)</label>
  <div class="password-wrapper">
    <input type="password" id="passphrase" />
    <span class="toggle-visibility" onclick="togglePassphrase()" title="Show/Hide">
      👁️
    </span>
  </div>
  <button type="button" onclick="copyPassphrase()">📋 Copy Passphrase to Clipboard</button>
  <!--<button type="button" onclick="generatePassphrase()">🔑 Generate Passphrase</button> //-->

  <button type="button" onclick="downloadPrivateKey()">💾 Download Private Key</button>
  <button type="button" onclick="signSecurityTxt()">✍️ Sign with PGP</button>

  <label>PGP-Signed security.txt</label>
  <textarea id="signedOutput" readonly></textarea>
  <button type="button" onclick="downloadSignedFile()">📄 Download Signed File</button>
</form>


<div id="toast">Passphrase copied to clipboard!</div>
<footer id="appFooter" style="text-align: center; margin-top: 3em; font-size: 0.9em; color: #666;"></footer>
</body>
</html>

